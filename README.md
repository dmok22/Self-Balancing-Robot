# elec391

```
Angle sensing, measurement and display with Arduino nano BLE sense IMU (accelerometer
and gyroscope)
```
```
ELEC 391 Electrical Engineering Design Studio II
```
Let us consider an inverted pendulum (which will become your self-balanced robot later) that
we want to balance using a certain control method (e.g. PID). This requires real-Gme
measurements of the deviaGon angle ğœƒ (theta) that the pendulum exhibits in a non-equilibrium
state. This assignment is asking you to use both the accelerometer and the gyroscope sensors to
measure this angle.

**1. Background**
The accelerometer and the gyroscope sensors on the Arduino nano BLE sense IMU
( **BMI270_BMM150** ) provide us two independent methods to compute the angle ğœƒ. From a
control theory standpoint, the angle ğœƒ is the error _e(t)_ and is zero at equilibrium (verGcal posiGon)
as shown in Figure 1. Both methods have advantages and disadvantages. They can be combined
to provide a beQer, more stable measurement than any of them in isolaGon.

```
Figure 1 - robot at equilibrium
```
**2. CompuGng angles with accelerometer readings**
An accelerometer will always indicate the gravitaGonal acceleraGon on its verGcal axis, when it
is either not moving along that axis, or moving at constant velocity. If the accelerometerâ€™s
verGcal axis is not aligned with the gravitaGonal acceleraGon (i.e., the angle ğœƒ is different from
zero), than the angle can be computed as:

```
Î¸= ğ‘ğ‘Ÿğ‘ğ‘¡ğ‘ğ‘›!!!" (1)
```
If the Glt angle is very small, we can approximate the arctan funcGon as a raGo (this is called a
small angle approximaGon), and so:
ğœƒâ‰ˆ!!!
"

## (2)

where ax, ay are the accelerometer readings on the x (horizontal) and y (verGcal) axes,
respecGvely, as shown in Figure 2.


```
Figure 2 - robot imbalanced at Î¸ angle
```
2.1 **Advantages of accelerometer reading** :
Because gravity always points in the verGcal direcGon, the reading error will have a zero mean.
The accelerometer does not accumulate any measurement bias (which gyroscopes typically do);
that means that the measured acceleraGon along the y (verGcal axis) is the true gravitaGonal
acceleraGon plus some zero-mean Gaussian noise.

2.2 **Disadvantages of accelerometer reading** :
The variance of the Gaussian noise can be quite large depending on the specific accelerometer.
Other components of the mechanical system (e.g. motors) can also add noise to the readings.
You will be able to observe the noise generated by the DC motor when you build your robot and
perform readings with the motors turned on (not as part of this assignment).

**3. CompuGng angles with gyroscope readings**
The gyroscope measures the rotaGon rate (a.k.a. angular speed) in degrees/second. This is the
same as the first order derivaGve of the angle with respect to Gme. So in order to compute the
angle of rotaGon, we need to integrate, and also need to know the reference angle (ğœƒ" theta
zero - integraGon constant). For a given sampling rate delta t (âˆ†ğ‘¡), the Glt angle can be
computed as:

ğœƒ=ğœƒ"+ ğ‘”#âˆ™âˆ†ğ‘¡ (3)
where gz is the gyroscope reading corresponding to the z axis. This is also referred to _pitch_ in the
context of describing an aeroplaneâ€™s movement to the air (together with _yaw_ and _roll_ ).

3.1 **Advantages of gyroscope reading** :
The readings from gyroscopes are typically less noisy than those of the accelerometer, by a
significant amount. This is true for short periods of Gme.

3.2 **Disadvantages of gyroscope reading** :
Due to the conGnuous integraGon, gyroscope measurements accumulate bias in Gme. This bias
is driven by a random process and can offset the real measurement by either a posiGve or
negaGve amount.


**4. Complementary filter**
We would like to combine the posiGve aspects of both sensor readings to achieve a more precise
measurement. A complementary filter can achieve the accurate short-term reading of the
gyroscope and the long-term stability of the accelerometer.

To implement a complementary filter for our angle measurement:

- Sample both gyroscope and accelerometer data
- Calculate the angle using accelerometer data
- Calculate the change in angle using gyro data
- Compute the complementary angle esGmaGon by performing a weighted average of the
    accelerometer angle and the sum of the previous complementary angle esGmate and the
    change in angle measured by gyroscope.
Choosing the complementary filter weights is part of tuning your system, and is done by
repeated experiments. The greater the weight on the accelerometer, the _less bias_ and _more
noise_ you see in your angle esGmates. Start with an accelerometer weight of ~0.01 and a gyro
weight of ~0.99. You can iniGalize the complementary angle using the accelerometer angle.
The output of the complementary filter can be expressed as:

```
ğœƒ$=ğ‘˜ 0 ğœƒ$%&+ğœƒ',$ 1 +( 1 âˆ’ğ‘˜)ğœƒ!,$ (4)
```
```
where k is a number from 0 to 1, ğœƒ$ is the filter output at discrete Gme n; ğœƒ$%& is the output
of the complementary filter at the previous discrete Gme n-1; ğœƒ',$ is the current angle
computed based on gyro reading; ğœƒ!,$ is the current angle computed based on accelerometer
reading.
```
```
Figure 3 - Algorithm flow for acc/gyro complementary filter
```
```
Task 1 â€“ Data PloQng [ 1 mark]
In order to check your results, validate your design choices, and debug your design, you will
need a way to plot your sensor readings in a graphical manner. Your task 1 is to figure out a
way to plot data in real Gme from an Arduino system (in parGcular the Nano 33 BLE sense) on
```

a PC or Mac screen. As a real-Gme sensor data source, you can use any of the sensors built-
into the Arduino board, or random readings from any of the analog input pins. The built-in
Serial PloQer of the Arduino IDE is **not** an acceptable soluGon. You should not use any external
circuitry (resistors, potenGometers, etc.)
Hint: Python is one of the most useful languages for data manipulaGon and plodng. If you do
not know Python, it is fine to use a LLM such as ChatGPT and direct it to write your code. If
you use LLMs, submit your prompt(s) with this assignment, not only your code.
Grading: demonstrate your real-Gme data plot to the TA, answer TAâ€™s quesGons.
Deliverables:

- task1.ino (Arduino code)
- task1.py (Python code)

**Task 2 â€“ CompuGng angles with accelerometer readings** [ 1 mark]
Write Arduino code to collect accelerometer data from the BMI270_BMM150 IMU and
compute the Glt angle of the sensor. Display this angle value using the plodng method you
developed for task 1. Angles must be calculated exactly as indicated earlier in this handout,
no extra processing (i.e. filtering) is allowed.
Grading: demonstrate your Glt angle calculaGon and plodng to the TA, answer TAâ€™s
quesGons.

**Task 3 â€“ CompuGng angles with gyro readings** [ 1 mark]
IdenGcal to task 3, but use gyroscope readings and calculaGons.
Grading: demonstrate your Glt angle calculaGon and plodng to the TA, answer TAâ€™s
quesGons.

**Task 4 â€“ Calculate angles using a complementary filter** [ 2 marks]
Using the complementary filter method, compute the Glt angle. You will have to experiment
and tune the value of the K coefficient to obtain a stable and accurate reading. On the same
plot, show the three datasets corresponding to the three methods, simultaneously.
Grading: demonstrate your complementary filter. Explain your tuning strategy for the k
coefficient to the TA.

**For all tasks** , demonstrate your angle readings at three different angles: 0Â° (verGcal), Â± 15 Â°,
and Â± 30 Â°.

**Submission** : upload your code for all four tasks as required by the Canvas assignment. Your
submission must be a single .zip archive that includes two files for each task, for a total of
eight files. For each task you must submit an Arduino program called taskx.ino, and a Python
script called taskx.py, where _x_ is the task number. The name of the .zip archive must be
group_yy.zip, where _yy_ is your group number.



